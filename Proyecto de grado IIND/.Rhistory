nivelka=VARselect(da.ts, lag.max = 8, type = "const")
nivelka$selection
niv1=VARorder(da.ts)
# Aplicamos la prueba de Johansen para la identificación de relaciones lineales
# entre las series, lo que nos indica la condición de cointegración.
johatest=ca.jo(da.ts, type = "trace", K=8, ecdet ="none", spec = "longrun")
summary(johatest)
pm25=diff(da[,1],1)
tmp=diff((da[,2]),1)
radsolar=diff(da[,3],1)
pressure=diff(da[,4],1)
ws=diff(da[,5],1)
z=cbind.data.frame(pm25,tmp,radsolar,pressure,ws)
head(z)
pm25=diff(da.ts[,1],1)
tmp=diff((da.ts[,2]),1)
radsolar=diff(da.ts[,3],1)
pressure=diff(da.ts[,4],1)
ws=diff(da.ts[,5],1)
z=cbind.data.frame(pm25,tmp,radsolar,pressure,ws)
head(z)
str(z)
str(z)
str(z)
vecm1 = VECM(z, lag=7, r=4, estim = ("ML"))
summary(vecm1)
# Para ello funcionan con VAR, hay que transformar, pasar de un obj VECM a un obj VAR:
varmod1 = vec2var(johatest, r=1)
# correlación:
ade1 = serial.test(varmod1, lags.pt = 5, type = "BG")
ade1
# Modelo de volatilidad autorregresivo condicionados - ARCH
hete1 = arch.test(varmod1, lags.multi = 15, multivariate.only = TRUE)
hete1
m1irf = irf(varmod1, n.ahead = 30, boot = TRUE)
#predicción eje Y: es la var dependiente, acorde el impulso X.
plot(m1irf)
tmp=diff((da.ts[,2]),1)
radsolar=diff(da.ts[,3],1)
# Limpiar el entorno
rm(list = ls())
## Librerias ------------------
library(pacman)
library(tidyverse) # Paquete grande de manipulacion
library(lubridate) # Paquete para manejo de fechas
library(skimr)     # Paquete para revision de datos
library(stargazer) # Paquete de tablas "bonitas", regs y estad desc
library(dplyr)     # Paquete parte de tidyverse donde esta mutate, select, filter, summarise...
library(rio)       # Paquete de importacion/exportacion de datos
library(gridExtra)
library(patchwork)
library(stats)
library(readxl)
library(writexl)
library(ggplot2)
library(officer)
library(flextable)
library(pscl)
library(corrplot)   # Para el gráfico de correlación
library(devtools)
library(fpp3)
library(tseries) # Importamos la librería de tserires para la aplicación de la prueba de Dickey Fuller.
library(PerformanceAnalytics)
library(fBasics)
library(tsDyn)
library(urca)
library(vars)
library(MTS)
library(xts)
library(quantmod)
library(stats)
library(fBasics)
library(ARDL)
library(urca)
library(TSstudio)
library(quantmod)
library(fields)
library(dygraphs)
options(warn = - 1)
# Manejo del directorio
getwd()
directorio <- "C:/Users/windows/Documents/GitHub/Problem_Set_1/Proyecto-de-grado-IIND/Proyecto de grado IIND/1. Datos"
setwd(directorio)
# Chequeo de los archivos del directorio
dir()
list.files()
## Importacion de los datos ------------------
install_formats() # Cuestiones de importacion de archivos del paquete rio
da <- import("7. Bogota_Promedio_Dias_Act_VECM.xlsx")
# Convertir la base de datos "da" a formato ts
da.ts <- ts(da[2:6], start = as.Date(2021), frequency = 365)
plot(da.ts)
pm25=diff(da.ts[,1],1)
tmp=diff((da.ts[,2]),1)
radsolar=diff(da.ts[,3],1)
pressure=diff(da.ts[,4],1)
ws=diff(da.ts[,5],1)
z=cbind.data.frame(pm25,tmp,radsolar,pressure,ws)
head(z)
str(z)
#Selección automatica:
models <- auto_ardl(pm25 ~ pressure + tmp + radsolar + ws, data = da.ts, lamda = TRUE,max_order = 6)
#Selección automatica:
models <- auto_ardl(pm25 ~ pressure + tmp + radsolar + ws, data = z, lamda = TRUE,max_order = 6)
#Revisemos el top 20 de los mejores modelos según su critrio de información de Akaike
models$top_orders
#Procedemos a construir el modelo de regresión con la mejor combinación.
mod1 <- ardl(pm25 ~ pressure + tmp + radsolar+ ws, data = da.ts, lamda = TRUE ,order = c(6,6,6,6,6))
#Procedemos a construir el modelo de regresión con la mejor combinación.
mod1 <- ardl(pm25 ~ pressure + tmp + radsolar+ ws, data = z, lamda = TRUE ,order = c(6,6,6,6,6))
summary(mod1)
# Para la interpretación, podemos imprimir los rezagos correspondientes de cada variable que explican la respuesta.
mod1$full_formula
#Predicción del primer modelo sin tendencia:
stats::predict(mod1$fitted.values, 10)
p_pm25 <- autoplot(predict(mod1$fitted.values, h=10)) +
geom_line() +
labs(x = "Tiempo",
y = "PM2.5",
title = "Predicción del PM2.5") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),  # Centra y ajusta el título
axis.title = element_text(size = 14),  # Ajusta el tamaño de las etiquetas de los ejes
axis.text = element_text(size = 12),   # Ajusta el tamaño del texto de los ejes
plot.background = element_rect(fill = "white"),  # Cambia el fondo del gráfico
panel.grid.minor = element_blank()  # Elimina las líneas de cuadrícula menores
)
p_pm25
# Exportar como PNG
ggsave("24. Predicción del PM2.5 desde 2021 hasta 2024.png",
plot = last_plot(),
path = "C:/Users/windows/Documents/GitHub/Problem_Set_1/Proyecto-de-grado-IIND/Proyecto de grado IIND/4. Gráficos",
width = 10, height = 6, units = "in", dpi = 300)
# Guardamos el mejor modelo obtenido en la sección anterior
modelo <- models$best_model
# Realizamos la prueba de hipotesis
# El parametro "case" igual a 2 verifica si existe relaciones a largo termino,
# con la combinación de (restricted constant, no linear trend).
bounds_f_test(modelo, case = 2)
# Multiplicadores a corto plazo
# sr_ short run
multipliers(modelo, type = "sr")
# Como el modelo presenta cointegración, aplica:
bounds_f_test(modelo, case = 3)
# Multiplicadores a largo plazo
multipliers(modelo, type = "lr")
a <- resid(modelo)
pacf(a, 30)
library(tsDyn)
library(vars)
library(urca)
library(forecast)
library(tidyverse)
checkresiduals(modelo)
# -----------------------------------------------------------
# Sección 1: Preparación de datos
# -----------------------------------------------------------
# Limpiar el entorno
rm(list = ls())
## Librerias ------------------
library(pacman)
library(tidyverse) # Paquete grande de manipulacion
library(lubridate) # Paquete para manejo de fechas
library(skimr)     # Paquete para revision de datos
library(stargazer) # Paquete de tablas "bonitas", regs y estad desc
library(dplyr)     # Paquete parte de tidyverse donde esta mutate, select, filter, summarise...
library(rio)       # Paquete de importacion/exportacion de datos
library(gridExtra)
library(patchwork)
library(stats)
library(readxl)
library(writexl)
library(ggplot2)
library(officer)
library(flextable)
library(pscl)
library(corrplot)   # Para el gráfico de correlación
library(devtools)
library(fpp3)
library(tseries) # Importamos la librería de tserires para la aplicación de la prueba de Dickey Fuller.
library(PerformanceAnalytics)
library(fBasics)
library(tsDyn)
library(urca)
library(vars)
library(MTS)
library(xts)
library(quantmod)
library(stats)
library(fBasics)
library(ARDL)
library(urca)
library(TSstudio)
library(quantmod)
library(fields)
library(dygraphs)
options(warn = - 1)
# Manejo del directorio
getwd()
directorio <- "C:/Users/windows/Documents/GitHub/Problem_Set_1/Proyecto-de-grado-IIND/Proyecto de grado IIND/1. Datos"
setwd(directorio)
# Chequeo de los archivos del directorio
dir()
list.files()
## Importacion de los datos ------------------
install_formats() # Cuestiones de importacion de archivos del paquete rio
da <- import("7. Bogota_Promedio_Dias_Act_VECM.xlsx")
# Convertir la base de datos "da" a formato ts
da.ts <- ts(da[2:6], start = as.Date(2021), frequency = 365)
plot(da.ts)
# ARDL (Autoregressive Distributed Lag)
# ARML Se puede aplicar, pues todas las series son estacionarias.
# Aplica para i1 e i0.
pm25=diff(da.ts[,1],1)
tmp=diff((da.ts[,2]),1)
radsolar=diff(da.ts[,3],1)
pressure=diff(da.ts[,4],1)
ws=diff(da.ts[,5],1)
z=cbind.data.frame(pm25,tmp,radsolar,pressure,ws)
head(z)
str(z)
# -----------------------------------------------------------
# Sección 2: Búsqueda tipo grid search
# -----------------------------------------------------------
#Selección automatica:
models <- auto_ardl(pm25 ~ pressure + tmp + radsolar + ws, data = z, lamda = TRUE,max_order = 6)
#Revisemos el top 20 de los mejores modelos según su critrio de información de Akaike
models$top_orders
# -----------------------------------------------------------
# Sección 3: Modelo ARDL
# -----------------------------------------------------------
#Procedemos a construir el modelo de regresión con la mejor combinación.
mod1 <- ardl(pm25 ~ pressure + tmp + radsolar+ ws, data = z, lamda = TRUE ,order = c(6,6,6,6,6))
summary(mod1)
# Para la interpretación, podemos imprimir los rezagos correspondientes de cada variable que explican la respuesta.
mod1$full_formula
#Predicción del primer modelo sin tendencia:
stats::predict(mod1$fitted.values, 10)
p_pm25 <- autoplot(predict(mod1$fitted.values, h=10)) +
geom_line() +
labs(x = "Tiempo",
y = "PM2.5",
title = "Predicción del PM2.5") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),  # Centra y ajusta el título
axis.title = element_text(size = 14),  # Ajusta el tamaño de las etiquetas de los ejes
axis.text = element_text(size = 12),   # Ajusta el tamaño del texto de los ejes
plot.background = element_rect(fill = "white"),  # Cambia el fondo del gráfico
panel.grid.minor = element_blank()  # Elimina las líneas de cuadrícula menores
)
p_pm25
# Exportar como PNG
ggsave("24. Predicción del PM2.5 desde 2021 hasta 2024.png",
plot = last_plot(),
path = "C:/Users/windows/Documents/GitHub/Problem_Set_1/Proyecto-de-grado-IIND/Proyecto de grado IIND/4. Gráficos",
width = 10, height = 6, units = "in", dpi = 300)
# -----------------------------------------------------------
# Sección 3: Bounds Test
# -----------------------------------------------------------
# Guardamos el mejor modelo obtenido en la sección anterior
modelo <- models$best_model
# Realizamos la prueba de hipotesis
# El parametro "case" igual a 2 verifica si existe relaciones a largo termino,
# con la combinación de (restricted constant, no linear trend).
bounds_f_test(modelo, case = 2)
# H0:NO Existe un equilibrio a corto plazo
# H1: Existe un equilibrio a corto plazo
# p-value = 1e-06 < 5%, se rechaza H0, Existe un equilibrio a corto plazo.
# Multiplicadores a corto plazo
# sr_ short run
multipliers(modelo, type = "sr")
# Interpretación de los coeficientes:
# - Por cada unidad de mmhg pressure, el PM2.5 disminuye en -1.29708135 µg/m3, en corto plazo.
# - Por cada unidad de C tmp, el PM2.5 disminuye en -0.25715563 µg/m3, en corto plazo.
# - Por cada unidad de W/M^2 radsolar, el PM2.5 disminuye en 0.03144708 µg/m3, en corto plazo.
# - Por cada unidad de M/S ws, el PM2.5 disminuye en -10.85602704 µg/m3, en corto plazo.
# Como el modelo presenta cointegración, aplica:
bounds_f_test(modelo, case = 3)
# H0:Existe un equilibrio a largo plazo
# H1:NO Existe un equilibrio a largo plazo
# p-value = 1e-06 < 5%, se rechaza H0, NO Existe un equilibrio a largo plazo.
# Multiplicadores a largo plazo
multipliers(modelo, type = "lr")
# - Por cada unidad de mmhg de pressure, el PM2.5 disminuye en -4.0469894 µg/m3, en corto plazo.
# - Por cada unidad de C de tmp, el PM2.5 disminuye en 0.6307268 µg/m3, en corto plazo.
# - Por cada unidad de W/M^2 de radsolar, el PM2.5 disminuye en 0.0892383 µg/m3, en corto plazo.
# - Por cada unidad de M/S de ws, el PM2.5 disminuye en -3.4238851 µg/m3, en corto plazo.
### Cuanto es el largo plazo???
a <- resid(modelo)
pacf(a, 30)
library(tsDyn)
library(vars)
library(urca)
library(forecast)
library(tidyverse)
checkresiduals(modelo)
# G1: No hay una tendencia obvia en los residuos, lo cual es bueno porque
# indica que el modelo no tiene sesgo sistemático a lo largo del tiempo.
# G2: Hay autocorrelación residual.
# Esto Puede subestimar o sobreestimar los coeficientes, el modelo no es tan bueno???
# G3: Normalidad en la distribución de los residuos.
# Limpiar el entorno
rm(list = ls())
## Librerias ------------------
library(pacman)
library(tidyverse) # Paquete grande de manipulacion
library(lubridate) # Paquete para manejo de fechas
library(skimr)     # Paquete para revision de datos
library(stargazer) # Paquete de tablas "bonitas", regs y estad desc
library(dplyr)     # Paquete parte de tidyverse donde esta mutate, select, filter, summarise...
library(rio)       # Paquete de importacion/exportacion de datos
library(gridExtra)
library(patchwork)
library(stats)
library(readxl)
library(writexl)
library(ggplot2)
library(officer)
library(flextable)
library(pscl)
# Manejo del directorio
getwd()
directorio <- "C:/Users/windows/Documents/GitHub/Problem_Set_1/Proyecto-de-grado-IIND/Proyecto de grado IIND/1. Datos"
setwd(directorio)
# Chequeo de los archivos del directorio
dir()
list.files()
## Importacion de los datos ------------------
install_formats() # Cuestiones de importacion de archivos del paquete rio
data <- import("4. Bogota_Promedio_Dias.RDS")
head(data)
## Variable de excesos y modelación binaria
# Crear variables de los excedentes
data <- data %>% mutate(ex_pm = case_when(pm25 >= 15 ~ 1,
.default = 0))
# Estimacion de la probabilidad de exceder el AGQ - Modelo PROBIT
# Variable dependiente: ex_pm
# as.factor(X): Definir variable como una categorica
probit_model <- glm(formula = ex_pm ~ rain + tmp + ws + rh + radsolar + as.factor(dow) + as.factor(month) + as.factor(year),
data = data,
family = binomial(link = "probit"))
# Chequeo de los resultados
stargazer(probit_model, type = "text", out = "C:/Users/windows/Documents/GitHub/Problem_Set_1/Proyecto-de-grado-IIND/Proyecto de grado IIND/5. Salidas de R/probit_model.doc")
# Pseudo R^2
pR2(probit_model)
# Valor de la función de log-verosimilitud
logLik(probit_model)
# Desvianza residual
deviance(probit_model)
# Modelo nulo
probit_model0 <- glm(formula = ex_pm ~ 1, data = data, family = binomial(link = "probit"))
# Valor de la función de log-verosimilitud
loglik_model <- logLik(probit_model)
# Estadístico de razón de verosimilitud
lrtest <- 2 * (logLik(probit_model) - logLik(probit_model0))
lrtest
# Pseudo R^2 de McFadden
pR2(probit_model, method = "mcfadden")
# AIC
AIC(probit_model)
# BIC
BIC(probit_model)
# Valores predichos en la base de datos
data <- data %>% mutate(ex_pm_hat = probit_model$fitted.values)
p_pm25_prob <- ggplot(data, aes(myday, ex_pm_hat)) +
geom_line() +
labs(x = "Tiempo",
y = "Probabilidad",
title = "Evoluación de la probabilidad") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),  # Centra y ajusta el título
axis.title = element_text(size = 14),  # Ajusta el tamaño de las etiquetas de los ejes
axis.text = element_text(size = 12),   # Ajusta el tamaño del texto de los ejes
plot.background = element_rect(fill = "white"),  # Cambia el fondo del gráfico
panel.grid.minor = element_blank()  # Elimina las líneas de cuadrícula menores
)
## Variable de excesos y modelación binaria
# Crear variables de los excedentes
data <- data %>% mutate(ex_pm = case_when(pm25 >= 15 ~ 1,
.default = 0))
# Estimacion de la probabilidad de exceder el AGQ - Modelo PROBIT
# Variable dependiente: ex_pm
# as.factor(X): Definir variable como una categorica
probit_model <- glm(formula = ex_pm ~ rain + tmp + ws + rh + radsolar + as.factor(dow) + as.factor(month) + as.factor(year),
data = data,
family = binomial(link = "probit"))
# Chequeo de los resultados
stargazer(probit_model, type = "text", out = "C:/Users/windows/Documents/GitHub/Problem_Set_1/Proyecto-de-grado-IIND/Proyecto de grado IIND/5. Salidas de R/probit_model.doc")
# Valores predichos en la base de datos
data <- data %>% mutate(ex_pm_hat = probit_model$fitted.values)
p_pm25_prob <- ggplot(data, aes(myday, ex_pm_hat)) +
geom_line() +
labs(x = "Tiempo",
y = "Probabilidad",
title = "Evoluación de la probabilidad") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),  # Centra y ajusta el título
axis.title = element_text(size = 14),  # Ajusta el tamaño de las etiquetas de los ejes
axis.text = element_text(size = 12),   # Ajusta el tamaño del texto de los ejes
plot.background = element_rect(fill = "white"),  # Cambia el fondo del gráfico
panel.grid.minor = element_blank()  # Elimina las líneas de cuadrícula menores
)
p_pm25_prob
p_pm25_prob <- ggplot(data, aes(myday, ex_pm_hat)) +
geom_line() +
labs(x = "Tiempo",
y = "Probabilidad",
title = "Evoluación de la probabilidad - PM2.5") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),  # Centra y ajusta el título
axis.title = element_text(size = 14),  # Ajusta el tamaño de las etiquetas de los ejes
axis.text = element_text(size = 12),   # Ajusta el tamaño del texto de los ejes
plot.background = element_rect(fill = "white"),  # Cambia el fondo del gráfico
panel.grid.minor = element_blank()  # Elimina las líneas de cuadrícula menores
)
p_pm25_prob
# Exportar como PNG
ggsave("9. Evoluación de la probabilidad PM2.5.png",
plot = last_plot(),
path = "C:/Users/windows/Documents/GitHub/Problem_Set_1/Proyecto-de-grado-IIND/Proyecto de grado IIND/4. Gráficos",
width = 10, height = 6, units = "in", dpi = 300)
p_pm25_prob2 <- ggplot(data, aes(ws, ex_pm_hat)) +
geom_point() +
labs(x = "Velocidad del Viento",
y = "Probabilidad",
title = "Evoluación de la probabilidad con Viento - PM2.5") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),  # Centra y ajusta el título
axis.title = element_text(size = 14),  # Ajusta el tamaño de las etiquetas de los ejes
axis.text = element_text(size = 12),   # Ajusta el tamaño del texto de los ejes
plot.background = element_rect(fill = "white"),  # Cambia el fondo del gráfico
panel.grid.minor = element_blank()  # Elimina las líneas de cuadrícula menores
)
p_pm25_prob2
# Exportar como PNG
ggsave("10. Evoluación de la probabilidad con Viento - PM2.5.png",
plot = last_plot(),
path = "C:/Users/windows/Documents/GitHub/Problem_Set_1/Proyecto-de-grado-IIND/Proyecto de grado IIND/4. Gráficos",
width = 10, height = 6, units = "in", dpi = 300)
## Manejo de la variable de velocidad del viento ------------
max(data$ws)
min(data$ws)
data <- data %>% mutate(ws_class = case_when(ws < 0.1 ~ 0,
ws >= 0.1 & ws < 0.3 ~ 0.2,
ws >= 0.3 & ws < 0.5 ~ 0.4,
ws >= 0.5 & ws < 0.7 ~ 0.6,
ws >= 0.7 & ws < 0.9 ~ 0.8,
ws >= 0.9 & ws < 1.1 ~ 1.0,
ws >= 1.1 & ws < 1.3 ~ 1.2,
ws >= 1.3 & ws < 1.5 ~ 1.4,
ws >= 1.5 & ws < 1.7 ~ 1.6,
ws >= 1.7 & ws < 1.9 ~ 1.8,
ws >= 1.9 & ws < 2.1 ~ 2.0,
ws >= 2.1 & ws < 2.3 ~ 2.2,
ws >= 2.3 & ws < 2.5 ~ 2.4,
ws >= 2.5 & ws < 2.7 ~ 2.6,
ws >= 2.7 & ws < 2.9 ~ 2.8,
ws >= 2.9 & ws < 3.1 ~ 3.0))
## Funcion Group_by() con summarise()
data_ws_col <- data %>% group_by(ws_class) %>%
summarise(mean_prob = mean(ex_pm_hat)) %>%
as.tibble()
p_pm25_col <- ggplot(data_ws_col, aes(ws_class, mean_prob)) +
geom_point() +
geom_line() +
labs(x = "Velocidad del Viento",
y = "Probabilidad",
title = "Evoluación de la probabilidad con Viento - PM2.5") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),  # Centra y ajusta el título
axis.title = element_text(size = 14),  # Ajusta el tamaño de las etiquetas de los ejes
axis.text = element_text(size = 12),   # Ajusta el tamaño del texto de los ejes
plot.background = element_rect(fill = "white"),  # Cambia el fondo del gráfico
panel.grid.minor = element_blank()  # Elimina las líneas de cuadrícula menores
)
p_pm25_col
# Exportar como PNG
ggsave("11. Evoluación de la probabilidad con Viento - PM2.5.png",
plot = last_plot(),
path = "C:/Users/windows/Documents/GitHub/Problem_Set_1/Proyecto-de-grado-IIND/Proyecto de grado IIND/4. Gráficos",
width = 10, height = 6, units = "in", dpi = 300)
data_ws_col2 <- data %>% group_by(ws_class, month) %>%
summarise(mean_prob = mean(ex_pm_hat)) %>%
as.tibble()
data_ws_col2 <- data_ws_col2 %>% mutate(month =  as.character(month))
p_pm25_col2 <- ggplot(data_ws_col2, aes(ws_class, mean_prob, col = month)) +
geom_point() +
geom_line() +
labs(x = "Velocidad del Viento",
y = "Probabilidad",
title = "Evoluación de la probabilidad con Viento") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),  # Centra y ajusta el título
axis.title = element_text(size = 14),  # Ajusta el tamaño de las etiquetas de los ejes
axis.text = element_text(size = 12),   # Ajusta el tamaño del texto de los ejes
plot.background = element_rect(fill = "white"),  # Cambia el fondo del gráfico
panel.grid.minor = element_blank()  # Elimina las líneas de cuadrícula menores
)
p_pm25_col2
# Exportar como PNG
ggsave("12. Evoluación de la probabilidad con Viento - PM2.5.png",
plot = last_plot(),
path = "C:/Users/windows/Documents/GitHub/Problem_Set_1/Proyecto-de-grado-IIND/Proyecto de grado IIND/4. Gráficos",
width = 10, height = 6, units = "in", dpi = 300)
